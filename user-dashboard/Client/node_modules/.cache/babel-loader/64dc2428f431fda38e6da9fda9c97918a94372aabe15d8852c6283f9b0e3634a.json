{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\UserOffice\\\\Desktop\\\\dashboard_react\\\\user-dashboard\\\\Client\\\\src\\\\components\\\\CanvasGlobe.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport * as topojson from \"topojson-client\";\nimport \"./CanvasGlobe.css\"; // Import the CSS file\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CanvasGlobe = ({\n  width,\n  height,\n  landColor = \"#\",\n  countryColor = \"#\",\n  borderColor = \"#fff\",\n  dotColor = \"#B7312C\",\n  waterColor = \"#041C2C\"\n}) => {\n  _s();\n  const globeContainerRef = useRef(null); // Use ref to keep track of the container\n  const animationRef = useRef(null); // Ref to store the animation frame ID\n\n  useEffect(() => {\n    var _window$devicePixelRa;\n    const dpr = (_window$devicePixelRa = window.devicePixelRatio) !== null && _window$devicePixelRa !== void 0 ? _window$devicePixelRa : 1;\n    const canvas = d3.create(\"canvas\").attr(\"width\", dpr * width).attr(\"height\", dpr * height).style(\"width\", `${width}px`).style(\"height\", `${height}px`).node();\n    const context = canvas.getContext(\"2d\");\n    context.scale(dpr, dpr);\n    const projection = d3.geoOrthographic().fitExtent([[10, 10], [width - 10, height - 10]], {\n      type: \"Sphere\"\n    });\n    const path = d3.geoPath(projection, context);\n    const tilt = 20;\n    const render = (country, arc, land, borders) => {\n      context.clearRect(0, 0, width, height);\n\n      // Draw water\n      context.beginPath();\n      path({\n        type: \"Sphere\"\n      });\n      context.fillStyle = waterColor;\n      context.fill();\n\n      // Draw land\n      context.beginPath();\n      path(land);\n      context.fillStyle = landColor;\n      context.fill();\n\n      // Draw country\n      context.beginPath();\n      path(country);\n      context.fillStyle = countryColor;\n      context.fill();\n\n      // Draw borders\n      context.beginPath();\n      path(borders);\n      context.strokeStyle = borderColor;\n      context.lineWidth = 0.5;\n      context.stroke();\n\n      // Draw the outline of the sphere\n      context.beginPath();\n      path({\n        type: \"Sphere\"\n      });\n      context.strokeStyle = \"#000\";\n      context.lineWidth = 1.5;\n      context.stroke();\n\n      // Draw the arc\n      context.beginPath();\n      context.setLineDash([2, 2]);\n      context.strokeStyle = dotColor;\n      path(arc);\n      context.stroke();\n      context.setLineDash([]);\n      return context.canvas;\n    };\n    const Versor = {\n      fromAngles: ([l, p, g]) => {\n        l *= Math.PI / 360;\n        p *= Math.PI / 360;\n        g *= Math.PI / 360;\n        const sl = Math.sin(l),\n          cl = Math.cos(l);\n        const sp = Math.sin(p),\n          cp = Math.cos(p);\n        const sg = Math.sin(g),\n          cg = Math.cos(g);\n        return [cl * cp * cg + sl * sp * sg, sl * cp * cg - cl * sp * sg, cl * sp * cg + sl * cp * sg, cl * cp * sg - sl * sp * cg];\n      },\n      toAngles: ([a, b, c, d]) => [Math.atan2(2 * (a * b + c * d), 1 - 2 * (b * b + c * c)) * 180 / Math.PI, Math.asin(Math.max(-1, Math.min(1, 2 * (a * c - d * b)))) * 180 / Math.PI, Math.atan2(2 * (a * d + b * c), 1 - 2 * (c * c + d * d)) * 180 / Math.PI],\n      interpolateAngles: (a, b) => {\n        const i = Versor.interpolate(Versor.fromAngles(a), Versor.fromAngles(b));\n        return t => Versor.toAngles(i(t));\n      },\n      interpolateLinear: ([a1, b1, c1, d1], [a2, b2, c2, d2]) => {\n        a2 -= a1;\n        b2 -= b1;\n        c2 -= c1;\n        d2 -= d1;\n        const x = new Array(4);\n        return t => {\n          const l = Math.hypot(x[0] = a1 + a2 * t, x[1] = b1 + b2 * t, x[2] = c1 + c2 * t, x[3] = d1 + d2 * t);\n          x[0] /= l;\n          x[1] /= l;\n          x[2] /= l;\n          x[3] /= l;\n          return x;\n        };\n      },\n      interpolate: ([a1, b1, c1, d1], [a2, b2, c2, d2]) => {\n        let dot = a1 * a2 + b1 * b2 + c1 * c2 + d1 * d2;\n        if (dot < 0) {\n          a2 = -a2;\n          b2 = -b2;\n          c2 = -c2;\n          d2 = -d2;\n        }\n        dot = -dot;\n        if (dot > 0.9995) return Versor.interpolateLinear([a1, b1, c1, d1], [a2, b2, c2, d2]);\n        const theta0 = Math.acos(Math.max(-1, Math.min(1, dot)));\n        const x = new Array(4);\n        const l = Math.hypot(a2 -= a1 * dot, b2 -= b1 * dot, c2 -= c1 * dot, d2 -= d1 * dot);\n        a2 /= l;\n        b2 /= l;\n        c2 /= l;\n        d2 /= l;\n        return t => {\n          const theta = theta0 * t;\n          const s = Math.sin(theta);\n          const c = Math.cos(theta);\n          x[0] = a1 * c + a2 * s;\n          x[1] = b1 * c + b2 * s;\n          x[2] = c1 * c + c2 * s;\n          x[3] = d1 * c + d2 * s;\n          return x;\n        };\n      }\n    };\n    const fetchData = async () => {\n      try {\n        const world = await d3.json(\"https://cdn.jsdelivr.net/npm/world-atlas@2/countries-50m.json\");\n        const land = topojson.feature(world, world.objects.land);\n        const countries = topojson.feature(world, world.objects.countries).features;\n        const borders = topojson.mesh(world, world.objects.countries, (a, b) => a !== b);\n\n        // Log all country IDs to verify, and filter out undefined values\n        const countryIds = countries.map(country => country.id).filter(id => id !== undefined);\n        console.log(\"Fetched country IDs:\", countryIds);\n\n        // Define the sequence of countries by their ISO 3166-1 numeric code as strings\n        const countrySequence = [\"840\", \"124\", \"250\", \"276\", \"392\"]; // Example: USA, Canada, France, Germany, Japan\n\n        // Filter countries based on the sequence\n        const countriesToRotate = countries.filter(country => countrySequence.includes(country.id));\n        if (countriesToRotate.length === 0) {\n          console.error(\"No countries found for the specified sequence.\");\n          return;\n        }\n        let p2 = [0, 0],\n          r2 = [0, 0, 0];\n        let countryIndex = 0;\n        const animate = async () => {\n          try {\n            const country = countriesToRotate[countryIndex];\n            const currentP2 = d3.geoCentroid(country);\n            const currentR2 = [-currentP2[0], tilt - currentP2[1], 0];\n            const ip = d3.geoInterpolate(p2, currentP2);\n            const iv = Versor.interpolateAngles(r2, currentR2);\n            const duration = 625; // Halve the duration to make it faster\n            const steps = duration / 16; // Assuming 60fps, so ~16ms per frame\n            let step = 0;\n            const rotate = () => {\n              if (step <= steps) {\n                const t = step / steps;\n                projection.rotate(iv(t));\n                render(country, {\n                  type: \"LineString\",\n                  coordinates: [p2, ip(t)]\n                }, land, borders);\n                step++;\n                animationRef.current = requestAnimationFrame(rotate);\n              } else {\n                p2 = currentP2;\n                r2 = currentR2;\n                countryIndex = (countryIndex + 1) % countriesToRotate.length;\n                setTimeout(() => {\n                  animationRef.current = requestAnimationFrame(animate);\n                }, 500); // Reduce the delay between rotations\n              }\n            };\n            rotate();\n          } catch (countryError) {\n            console.error(\"Error processing country:\", countryError);\n            countryIndex = (countryIndex + 1) % countriesToRotate.length;\n            animationRef.current = requestAnimationFrame(animate);\n          }\n        };\n        animationRef.current = requestAnimationFrame(animate);\n      } catch (error) {\n        console.error(\"Error fetching world data:\", error.message || error);\n      }\n    };\n    fetchData().catch(error => {\n      console.error(\"Error in fetchData:\", error.message || error);\n    });\n    const globeContainer = globeContainerRef.current;\n\n    // Remove any existing canvas elements to avoid duplicate globes\n    if (globeContainer.firstChild) {\n      globeContainer.removeChild(globeContainer.firstChild);\n    }\n    globeContainer.appendChild(canvas);\n    console.log(\"Canvas appended to container\");\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, [width, height, landColor, countryColor, borderColor, dotColor, waterColor]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: \"globe-container\",\n    ref: globeContainerRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 293,\n    columnNumber: 10\n  }, this);\n};\n_s(CanvasGlobe, \"DM+HF7+Bcm8rOT/KHxKC896a14E=\");\n_c = CanvasGlobe;\nexport default CanvasGlobe;\nvar _c;\n$RefreshReg$(_c, \"CanvasGlobe\");","map":{"version":3,"names":["React","useEffect","useRef","d3","topojson","jsxDEV","_jsxDEV","CanvasGlobe","width","height","landColor","countryColor","borderColor","dotColor","waterColor","_s","globeContainerRef","animationRef","_window$devicePixelRa","dpr","window","devicePixelRatio","canvas","create","attr","style","node","context","getContext","scale","projection","geoOrthographic","fitExtent","type","path","geoPath","tilt","render","country","arc","land","borders","clearRect","beginPath","fillStyle","fill","strokeStyle","lineWidth","stroke","setLineDash","Versor","fromAngles","l","p","g","Math","PI","sl","sin","cl","cos","sp","cp","sg","cg","toAngles","a","b","c","d","atan2","asin","max","min","interpolateAngles","i","interpolate","t","interpolateLinear","a1","b1","c1","d1","a2","b2","c2","d2","x","Array","hypot","dot","theta0","acos","theta","s","fetchData","world","json","feature","objects","countries","features","mesh","countryIds","map","id","filter","undefined","console","log","countrySequence","countriesToRotate","includes","length","error","p2","r2","countryIndex","animate","currentP2","geoCentroid","currentR2","ip","geoInterpolate","iv","duration","steps","step","rotate","coordinates","current","requestAnimationFrame","setTimeout","countryError","message","catch","globeContainer","firstChild","removeChild","appendChild","cancelAnimationFrame","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/UserOffice/Desktop/dashboard_react/user-dashboard/Client/src/components/CanvasGlobe.js"],"sourcesContent":["import React, { useEffect, useRef } from \"react\";\r\nimport * as d3 from \"d3\";\r\nimport * as topojson from \"topojson-client\";\r\nimport \"./CanvasGlobe.css\"; // Import the CSS file\r\n\r\nconst CanvasGlobe = ({\r\n  width,\r\n  height,\r\n  landColor = \"#\",\r\n  countryColor = \"#\",\r\n  borderColor = \"#fff\",\r\n  dotColor = \"#B7312C\",\r\n  waterColor = \"#041C2C\",\r\n}) => {\r\n  const globeContainerRef = useRef(null); // Use ref to keep track of the container\r\n  const animationRef = useRef(null); // Ref to store the animation frame ID\r\n\r\n  useEffect(() => {\r\n    const dpr = window.devicePixelRatio ?? 1;\r\n    const canvas = d3\r\n      .create(\"canvas\")\r\n      .attr(\"width\", dpr * width)\r\n      .attr(\"height\", dpr * height)\r\n      .style(\"width\", `${width}px`)\r\n      .style(\"height\", `${height}px`)\r\n      .node();\r\n    const context = canvas.getContext(\"2d\");\r\n    context.scale(dpr, dpr);\r\n\r\n    const projection = d3.geoOrthographic().fitExtent(\r\n      [\r\n        [10, 10],\r\n        [width - 10, height - 10],\r\n      ],\r\n      { type: \"Sphere\" }\r\n    );\r\n    const path = d3.geoPath(projection, context);\r\n    const tilt = 20;\r\n\r\n    const render = (country, arc, land, borders) => {\r\n      context.clearRect(0, 0, width, height);\r\n\r\n      // Draw water\r\n      context.beginPath();\r\n      path({ type: \"Sphere\" });\r\n      context.fillStyle = waterColor;\r\n      context.fill();\r\n\r\n      // Draw land\r\n      context.beginPath();\r\n      path(land);\r\n      context.fillStyle = landColor;\r\n      context.fill();\r\n\r\n      // Draw country\r\n      context.beginPath();\r\n      path(country);\r\n      context.fillStyle = countryColor;\r\n      context.fill();\r\n\r\n      // Draw borders\r\n      context.beginPath();\r\n      path(borders);\r\n      context.strokeStyle = borderColor;\r\n      context.lineWidth = 0.5;\r\n      context.stroke();\r\n\r\n      // Draw the outline of the sphere\r\n      context.beginPath();\r\n      path({ type: \"Sphere\" });\r\n      context.strokeStyle = \"#000\";\r\n      context.lineWidth = 1.5;\r\n      context.stroke();\r\n\r\n      // Draw the arc\r\n      context.beginPath();\r\n      context.setLineDash([2, 2]);\r\n      context.strokeStyle = dotColor;\r\n      path(arc);\r\n      context.stroke();\r\n      context.setLineDash([]);\r\n\r\n      return context.canvas;\r\n    };\r\n\r\n    const Versor = {\r\n      fromAngles: ([l, p, g]) => {\r\n        l *= Math.PI / 360;\r\n        p *= Math.PI / 360;\r\n        g *= Math.PI / 360;\r\n        const sl = Math.sin(l),\r\n          cl = Math.cos(l);\r\n        const sp = Math.sin(p),\r\n          cp = Math.cos(p);\r\n        const sg = Math.sin(g),\r\n          cg = Math.cos(g);\r\n        return [\r\n          cl * cp * cg + sl * sp * sg,\r\n          sl * cp * cg - cl * sp * sg,\r\n          cl * sp * cg + sl * cp * sg,\r\n          cl * cp * sg - sl * sp * cg,\r\n        ];\r\n      },\r\n      toAngles: ([a, b, c, d]) => [\r\n        (Math.atan2(2 * (a * b + c * d), 1 - 2 * (b * b + c * c)) * 180) /\r\n          Math.PI,\r\n        (Math.asin(Math.max(-1, Math.min(1, 2 * (a * c - d * b)))) * 180) /\r\n          Math.PI,\r\n        (Math.atan2(2 * (a * d + b * c), 1 - 2 * (c * c + d * d)) * 180) /\r\n          Math.PI,\r\n      ],\r\n      interpolateAngles: (a, b) => {\r\n        const i = Versor.interpolate(\r\n          Versor.fromAngles(a),\r\n          Versor.fromAngles(b)\r\n        );\r\n        return (t) => Versor.toAngles(i(t));\r\n      },\r\n      interpolateLinear: ([a1, b1, c1, d1], [a2, b2, c2, d2]) => {\r\n        a2 -= a1;\r\n        b2 -= b1;\r\n        c2 -= c1;\r\n        d2 -= d1;\r\n        const x = new Array(4);\r\n        return (t) => {\r\n          const l = Math.hypot(\r\n            (x[0] = a1 + a2 * t),\r\n            (x[1] = b1 + b2 * t),\r\n            (x[2] = c1 + c2 * t),\r\n            (x[3] = d1 + d2 * t)\r\n          );\r\n          x[0] /= l;\r\n          x[1] /= l;\r\n          x[2] /= l;\r\n          x[3] /= l;\r\n          return x;\r\n        };\r\n      },\r\n      interpolate: ([a1, b1, c1, d1], [a2, b2, c2, d2]) => {\r\n        let dot = a1 * a2 + b1 * b2 + c1 * c2 + d1 * d2;\r\n        if (dot < 0) {\r\n          a2 = -a2;\r\n          b2 = -b2;\r\n          c2 = -c2;\r\n          d2 = -d2;\r\n        }\r\n        dot = -dot;\r\n        if (dot > 0.9995)\r\n          return Versor.interpolateLinear([a1, b1, c1, d1], [a2, b2, c2, d2]);\r\n        const theta0 = Math.acos(Math.max(-1, Math.min(1, dot)));\r\n        const x = new Array(4);\r\n        const l = Math.hypot(\r\n          (a2 -= a1 * dot),\r\n          (b2 -= b1 * dot),\r\n          (c2 -= c1 * dot),\r\n          (d2 -= d1 * dot)\r\n        );\r\n        a2 /= l;\r\n        b2 /= l;\r\n        c2 /= l;\r\n        d2 /= l;\r\n        return (t) => {\r\n          const theta = theta0 * t;\r\n          const s = Math.sin(theta);\r\n          const c = Math.cos(theta);\r\n          x[0] = a1 * c + a2 * s;\r\n          x[1] = b1 * c + b2 * s;\r\n          x[2] = c1 * c + c2 * s;\r\n          x[3] = d1 * c + d2 * s;\r\n          return x;\r\n        };\r\n      },\r\n    };\r\n\r\n    const fetchData = async () => {\r\n      try {\r\n        const world = await d3.json(\r\n          \"https://cdn.jsdelivr.net/npm/world-atlas@2/countries-50m.json\"\r\n        );\r\n        const land = topojson.feature(world, world.objects.land);\r\n        const countries = topojson.feature(\r\n          world,\r\n          world.objects.countries\r\n        ).features;\r\n        const borders = topojson.mesh(\r\n          world,\r\n          world.objects.countries,\r\n          (a, b) => a !== b\r\n        );\r\n\r\n        // Log all country IDs to verify, and filter out undefined values\r\n        const countryIds = countries\r\n          .map((country) => country.id)\r\n          .filter((id) => id !== undefined);\r\n        console.log(\"Fetched country IDs:\", countryIds);\r\n\r\n        // Define the sequence of countries by their ISO 3166-1 numeric code as strings\r\n        const countrySequence = [\"840\", \"124\", \"250\", \"276\", \"392\"]; // Example: USA, Canada, France, Germany, Japan\r\n\r\n        // Filter countries based on the sequence\r\n        const countriesToRotate = countries.filter((country) =>\r\n          countrySequence.includes(country.id)\r\n        );\r\n\r\n        if (countriesToRotate.length === 0) {\r\n          console.error(\"No countries found for the specified sequence.\");\r\n          return;\r\n        }\r\n\r\n        let p2 = [0, 0],\r\n          r2 = [0, 0, 0];\r\n\r\n        let countryIndex = 0;\r\n\r\n        const animate = async () => {\r\n          try {\r\n            const country = countriesToRotate[countryIndex];\r\n            const currentP2 = d3.geoCentroid(country);\r\n            const currentR2 = [-currentP2[0], tilt - currentP2[1], 0];\r\n\r\n            const ip = d3.geoInterpolate(p2, currentP2);\r\n            const iv = Versor.interpolateAngles(r2, currentR2);\r\n\r\n            const duration = 625; // Halve the duration to make it faster\r\n            const steps = duration / 16; // Assuming 60fps, so ~16ms per frame\r\n            let step = 0;\r\n\r\n            const rotate = () => {\r\n              if (step <= steps) {\r\n                const t = step / steps;\r\n                projection.rotate(iv(t));\r\n                render(\r\n                  country,\r\n                  { type: \"LineString\", coordinates: [p2, ip(t)] },\r\n                  land,\r\n                  borders\r\n                );\r\n                step++;\r\n                animationRef.current = requestAnimationFrame(rotate);\r\n              } else {\r\n                p2 = currentP2;\r\n                r2 = currentR2;\r\n                countryIndex = (countryIndex + 1) % countriesToRotate.length;\r\n                setTimeout(() => {\r\n                  animationRef.current = requestAnimationFrame(animate);\r\n                }, 500); // Reduce the delay between rotations\r\n              }\r\n            };\r\n\r\n            rotate();\r\n          } catch (countryError) {\r\n            console.error(\"Error processing country:\", countryError);\r\n            countryIndex = (countryIndex + 1) % countriesToRotate.length;\r\n            animationRef.current = requestAnimationFrame(animate);\r\n          }\r\n        };\r\n\r\n        animationRef.current = requestAnimationFrame(animate);\r\n      } catch (error) {\r\n        console.error(\"Error fetching world data:\", error.message || error);\r\n      }\r\n    };\r\n\r\n    fetchData().catch((error) => {\r\n      console.error(\"Error in fetchData:\", error.message || error);\r\n    });\r\n\r\n    const globeContainer = globeContainerRef.current;\r\n\r\n    // Remove any existing canvas elements to avoid duplicate globes\r\n    if (globeContainer.firstChild) {\r\n      globeContainer.removeChild(globeContainer.firstChild);\r\n    }\r\n\r\n    globeContainer.appendChild(canvas);\r\n    console.log(\"Canvas appended to container\");\r\n\r\n    return () => {\r\n      if (animationRef.current) {\r\n        cancelAnimationFrame(animationRef.current);\r\n      }\r\n    };\r\n  }, [\r\n    width,\r\n    height,\r\n    landColor,\r\n    countryColor,\r\n    borderColor,\r\n    dotColor,\r\n    waterColor,\r\n  ]);\r\n\r\n  return <div id=\"globe-container\" ref={globeContainerRef}></div>;\r\n};\r\n\r\nexport default CanvasGlobe;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}